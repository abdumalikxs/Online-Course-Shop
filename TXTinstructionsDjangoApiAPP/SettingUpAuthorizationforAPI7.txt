We can read information about courses and categories using GET method,
but we cant delete resources, or create new resources.

Because its not allowed to change, delete or reate new resources without authorization of a user.
But it is allowed to display resources without authorization and authentication.

Meaning we can open URLS without authentication but to edit resources we should have
been authenticated.


That's why let's set up authentication and authorization in our app,
so that we can edit the resources.

In models.py we allowed editing with methods POST and DELETE only for our 
Course resource, but for Category any editing via API is prohibited.


-------
To implement authentication and authorization we will create a separate Class for 
authentication of the user.
And we will do so that GET requests will be allowed without authentication
and the rest requests such as post and delete will be allowed only
after authentication and authorization


So how do we do it in TastyPie ? 

At first we are gonna create one mroe file in api directory, and we will call
it authentication.py

-----
And in this file we are gonna create a class called 'CustomAuthentication'
because we want to turn on authentication for all of the methods except 'get' method.

for this we first import this from tastypie package:
from tastypie.authentication import ApiKeyAuthentication

- because we will be doing authentication based on API key

	•	An API key is a unique token linked to a user account.
	•	When a client (like Postman or another app) makes requests to your API, it must include the user’s API key.
	•	Tastypie then checks if the key is valid and belongs to an authorized user.
	•	This way, GET requests can stay open (no key needed), but for sensitive operations like POST 
    (create) and DELETE (remove), the API will only accept the request 
    if the user provides a valid key.

And the users should send their API keys in the headers of their requests.
We will create API keys later.

now we have somethign like this:
class CustomAuthentication(ApiKeyAuthentication):
    def is_authenticated(self, request, **kwargs):
        return super().is_authenticated(request, **kwargs)


---- when we wrote is_authenticated it wrote by itself everything,
it happens because it gave the version of is_authenticated from parent class same same
so that now we can override it.

as we remember kwargs and args worked like this:

def demo(*args, **kwargs):
    print("args:", args)        # tuple of extra positional arguments
    print("kwargs:", kwargs)    # dict of extra keyword arguments

demo(1, 2, 3, name="Abdumalik", age=19)

Output: 
args: (1, 2, 3)
kwargs: {'name': 'Abdumalik', 'age': 19}


Ok, so now to go on in this method we want to do this:

class CustomAuthentication(ApiKeyAuthentication):
    def is_authenticated(self, request, **kwargs):
        if request.method == 'GET':
            return True
        
        return super().is_authenticated(request, **kwargs)


--- Now if our request method type is GET we return true so that the user won't 
have to go trhough authentication process.

Basically there already was such method called is_authenticated inside ApiKeyAuthentication
but in our own CustomAuthentication Class we implemented the same method, and changed
the behavior of this method. Skipping auth for method 'GET' but for all of other 
methods of requests we called is_authenticated from the parent class ApiKeyAuthentication
basically for the rest of our request method types.

Next we will let our API know to use our CustomAuthentication instead of Tastypie's base 
Authentication class, which always returns True (no checks, anyone can do anything) in the 
models.py . 

In models.py we have Categoryresource and CourseResource.

To mention :
👉 Authentication = identity check  (Answers for question: Who are you?)
👉 Authorization = permission check (Indicates what a user allowed to do, who already passed Authentication)

We should import these now:
from tastypie.authorization import Authorization   # Authorization is a class.
from .authentication import CustomAuthentication


Now we are gonna edit CourseResource, we are gonna add attributes to it:

class CourseResource(ModelResource):
    class Meta():
        queryset = Course.objects.all()
        resource_name = 'courses'
        allowed_methods = ['get', 'post', 'delete']
        # we create instance of CustomAuthentication so API can use our is_authenticated via instance
        authentication = CustomAuthentication()
        # If you wanted more control (e.g., only the course owner can delete), you’d replace this with a custom Authorization class.
        authorization = Authorization()

Overall we are doing authentication for all of the request methods except GET request method.

******
Now let's compare the work of CategoryResource's authentication and the CourseResource's.

class CategoryResource(ModelResource):
    class Meta():
        queryset = Category.objects.all()
        # It tells Tastypie what the endpoint URL for this resource should look like.
        resource_name = 'categories'
        allowed_methods = ['get']

	•	No authentication or authorization specified.
	•	Tastypie falls back to its defaults:
	•	Authentication → Authentication() (always returns True).
	•	Authorization → Authorization() (always allows).
	•	But since you limited allowed_methods = ['get'], it only responds to GET anyway, and GET doesn’t require authentication.
✅ Result → Anyone can list/read categories, but they can’t edit/delete them (because methods are restricted).
but if DELETE and POST would be inside allowed_methods everyone could do anything

-/---/-/-/-/--/-/--//--/--//-/--//--//--//-/-/--//--/
class CourseResource(ModelResource):
    class Meta():
        queryset = Course.objects.all()
        resource_name = 'courses'
        allowed_methods = ['get', 'post', 'delete']
        # we create instance of CustomAuthentication so API can use our is_authenticated via instance
        authentication = CustomAuthentication()
        # If you wanted more control (e.g., only the course owner can delete), you’d replace this with a custom Authorization class.
        authorization = Authorization()
------------->>>>>
	•	Here you explicitly set authentication = CustomAuthentication().
	•	That means:
	•	GET → always allowed (because your CustomAuthentication returns True for GET).
	•	POST/DELETE → only allowed if a valid API key is sent.
	•	Then authorization = Authorization() says “once authenticated, you can perform the allowed methods.”

✅ Result → Anyone can read courses, but only authenticated users can create or delete them.

-----

NEXT --> we have to create an API key so that we can send POST or DELETE requests